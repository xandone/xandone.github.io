---
layout: post
title: 谈谈Android图片压缩
date: 2017-06-08 22:51:37
tags: [编程]
toc:  true
---
**1.原色**  
牛顿通过三棱镜折射发现自然光是可以分解的:  

他进一步研究，发现自然界只有三种光不能被分解，即红绿蓝（RGB），  

而其他颜色的光均可由这三种光配制而成，因此将红绿蓝称为原色（三单色）。  

**2.颜色的表示**  
艺术界，每种颜色根据颜色的深浅，分为256色（灰度级），计算机中，1bit可以表示两个数（0和1），而：  
1byte=8bit，28=256（2的8次方）  
计算机中用1byte（8位的bit值）囊括一种原色，世界上所有的颜色均可以由三原色配制而成，例如计算机想表示某种浅黄色，它就用三原色的数值（253，244，175）进行表示:  

于是，每单位面积颜色由：  
3×8=24位的bit值组成（3字节）  
人们后来又给颜色定义了透明通道（Alpha值），透明程度也分为256级，因此每单位面积的颜色最终使用32位的bit值进行表示（占4个字节）。  
这里的“每单位面积”即为一个像素。  
计算机也正是通过“存储和拼凑”这样一个个的像素点进行显示图片，例如如下这张手机：  

通过无限放大后：  

手机变得非常模糊，再仔细观察，图片显示的是一个个的正方块，这每一个正方块都是一个像素点。  

**3.图片的存储：**  
另外，计算机中有多种关于存储图片的格式（png，jpg，webp...），分别用各自的算法都对照片进行了相应的压缩处理，这样能有效减少图片占用的内存。  

Signature：签名  
IHDR：头文件数据  
IDAT：数据块  
IEND：结束块  
图片点击右键查看的信息，为IHDR数据携带的信息。  
无损压缩：通过对冗余数据的存储方式进行优化，该方式不会丢失文件内容，压缩率受冗余度的影响，所以压缩率较低；  
有损压缩：通过丢失不会对文件造成太大影响的数据来达到压缩效果，所以压缩率较高；  
其中png是无损压缩格式图片，jpg是有损压缩格式图片, webp同时提供了提供了无损和有损压缩能力。  
因此App中选用png格式的图标作为素材，因为该格式为无损压缩，不会出现锯齿，同时该格式提供了Alpha通道。  

**4.图片的压缩策略：**  
Android系统底层基于Linux，每个（常规）App应用运行过程fork出一个单独的进程，分配16/24M的内存空间，因此资源是紧缺的，而App读取图片资源的过程是非常消耗资源，在保证图片视觉不失真前提下缩小体积，对于节省带宽和电池电量十分重要。  
加载数据流中关于图片的宽（w）高（h）。  

github上有一个开源库做得比较好Luban ，它的大致计算过程如下   
```
1>判断图片比例值，是否处于以下区间内:
[1, 0.5625) 即图片处于 [1:1 ~ 9:16) 比例范围内
[0.5625, 0.5) 即图片处于 [9:16 ~ 1:2) 比例范围内
[0.5, 0) 即图片处于 [1:2 ~ 1:∞) 比例范围内
2>判断图片最长边是否过边界值:
[1, 0.5625) 边界值为：1664 * n（n=1）, 4990 * n（n=2）, 1280 * pow(2, n-1)（n≥3）
[0.5625, 0.5) 边界值为：1280 * pow(2, n-1)（n≥1）
[0.5, 0) 边界值为：1280 * pow(2, n-1)（n≥1）
3>计算压缩图片实际边长值，
以第2步计算结果为准，超过某个边界值则：width / pow(2, n-1)，height/pow(2, n-1)
4>计算压缩图片的实际文件大小，
以第2、3步结果为准，图片比例越大则文件越大。
size = (newW * newH) / (width * height) * m；
[1, 0.5625) 则 width & height 对应 1664，4990，1280 * n（n≥3），m 对应 150，300，300；
[0.5625, 0.5) 则 width = 1440，height = 2560, m = 200；
[0.5, 0) 则 width = 1280，height = 1280 / scale，m = 500；注：scale为比例值
5>判断第4步的size是否过小
[1, 0.5625) 则最小 size 对应 60，60，100
[0.5625, 0.5) 则最小 size 都为 100
[0.5, 0) 则最小 size 都为 100
6>将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值
```